@using RoyalIdentity.Contracts
@using RoyalIdentity.Events
@using RoyalIdentity.Extensions;
@using RoyalIdentity.Users

@inject ISignInManager SignInManager
@inject ILogger<Login> Logger
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager
@inject IEventDispatcher EventDispatcher;

<StatusMessage Message="@errorMessage" MessageClass="danger"/>

<EditForm Model="Input" method="post" OnValidSubmit="LoginUser" FormName="login">
    <DataAnnotationsValidator/>
    <ValidationSummary class="text-danger" role="alert"/>

    <InputText @bind-Value="Input.ReturnUrl" type="hidden" />

    <div class="form-floating mb-3">
        <InputText @bind-Value="Input.Username" class="form-control" id="Username" autocomplete="username" aria-required="true" placeholder="Username"/>
        <label for="Username" class="form-label">Username</label>
        <ValidationMessage For="() => Input.Username" class="text-danger"/>
    </div>

    <div class="form-floating mb-3">
        <InputText type="password" @bind-Value="Input.Password" class="form-control" id="Password" autocomplete="off" aria-required="true"/>
        <label for="Password" class="form-label">Password</label>
        <ValidationMessage For="() => Input.Password" class="text-danger"/>
    </div>

    @if (Model.AllowRememberLogin)
    {
        <div class="checkbox mb-3">
            <label class="form-label">
                <InputCheckbox @bind-Value="Input.RememberLogin" class="darker-border-checkbox form-check-input"/>
                Remember My Login
            </label>
        </div>
    }

    <div>
        <button type="submit" class="w-100 btn btn-lg btn-primary">Log in</button>
    </div>

    <div class="mt-2">
        <p class="text-center">
            <a href="account/forgot-password">Forgot your password?</a>
        </p>
    </div>
</EditForm>


@code {
    private string? errorMessage;

    [Parameter, EditorRequired]
    public LoginViewModel Model { get; set; } = default!;

    [SupplyParameterFromForm]
    private LoginInputModel Input { get; set; } = new();

    protected override Task OnParametersSetAsync()
    {
        Input.ReturnUrl = Model.ReturnUrl;
        return base.OnParametersSetAsync();
    }

    public async Task LoginUser()
    {
        var context = await SignInManager.GetAuthorizationContextAsync(Input.ReturnUrl, default);

        var result = await SignInManager.ValidateCredentialsAsync(Input.Username!, Input.Password!, default);

        if (!result.Success)
        {
            errorMessage = result.ErrorMessage;
            var evt = new UserLoginFailureEvent(Input.Username!, errorMessage, context);
            await EventDispatcher.DispatchAsync(evt);
            return;
        }

        var user = result.User!;
        var evt2 = new UserLoginSuccessEvent(Input.Username!, user, context);
        await EventDispatcher.DispatchAsync(evt2);

        await SignInManager.SignInAsync(user, Input.RememberLogin, "pwd", default);

        if (context is not null)
        {
            // if consent is required, navigate to consent page
            if (context.RequiredConsent)
            {
                var consentUrl = "/account/consent".AddQueryString("returnUrl", Input.ReturnUrl!);
                NavigationManager.NavigateTo(consentUrl);
            }

            var redirectUri = context.RedirectUri;

            if (!redirectUri.StartsWith("http", StringComparison.OrdinalIgnoreCase))
            {
                // The client is native, so this change in how to
                // return the response is for better UX for the end user.
                NavigationManager.NavigateTo("/account/signedin?redirectUri=" + redirectUri);
            }

            // we can trust in the redirectUri since GetAuthorizationContextAsync returned non-null
            NavigationManager.NavigateTo(context.RedirectUri);
        }

        if (string.IsNullOrEmpty(Input.ReturnUrl))
        {
            NavigationManager.NavigateTo("/", true);
        }

        var uri = new Uri(Input.ReturnUrl!, UriKind.RelativeOrAbsolute);

        // if it's an absolute URI, and it's not a local page (from the same host) it throws an exception
        if (uri is { IsAbsoluteUri: true, IsLoopback: false })
        {
            throw new Exception("invalid return URL");
        }

        // redirect to the return URL
        NavigationManager.NavigateTo(uri.ToString(), true);
    }

}